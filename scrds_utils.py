# scrds_utils.R
#
# Wrapper to work with scRDS ingestion specifically for Abio annotated data
# Nizar Batada
# Version 1
# 12-12-2024

library(scRDS)
library(Seurat)
library(dplyr)
library(stringr)

#
# ingests a list of abio data provided in a csv file
# This file is generated by abio_sheet_add_datahandle.py and has these required columns:
# c("dataset_ID", "data_handle", "rds_in", "rds_out", "description")
#  
#


# setDBURL(url=scRDS:::TEST_DB_URI) # will send to sandbox https://singlecell.gilead.com/?mode=test
# https://singlecell.gilead.com/?mode=test

# https://github.com/Gilead-Research-Data-Sciences/scRDS/blob/f16e543657d9c214fdb5d84ba2e7ba606e27d39a/R/ingest.R
ingestAbioData <- function(rds_in, rds_out, DESCRIPTION) {
    tryCatch({
        message("[INFO]: Reading the Seurat object: ", rds_in)
        sobj <- readRDS(rds_in)
        message("[INFO]: Loaded Seurat object from ", rds_in)
        
        message("[INFO]: Seurat object version: ", paste(Version(sobj), collapse = "."))

        if (DefaultAssay(sobj) != "RNA") stop("[Error: DefaultAssay]: Must have 'RNA' assay")
        if (!all(c('data', 'counts') %in% Layers(sobj))) stop("[Error: Layers]: Missing counts and/or data")
        if (!all(c('nCount_RNA', 'nFeature_RNA', 'percent.mito', 'condition', 'fraction') %in% colnames(sobj@meta.data))) {
                stop("[Error: sobj@meta.data]: Missing 'nCount_RNA', 'nFeature_RNA', 'percent.mito', 'condition', 'fraction'")
        }
        if (!any(c('umap', 'tsne') %in% names(sobj@reductions))) stop("[Error: sobj@reduction]: UMAP or t-SNE required.")
        if (!all(c('experiment', 'celltypes') %in% names(Misc(sobj)))) stop("[Error: sobj@misc]: Missing slots 'experiment' and 'celltypes'")

        #----------------
        # sobj@misc$celltypes
        #------------------
        sobj <- correct_colnames_in_misc_celltypes(sobj, 'celltypes', 'celltype')  # fix typo
        sobj <- correct_colnames_in_misc_celltypes(sobj, 'catagory', 'category')  # fix typo
    	if ( !all(c("category", "celltype", "description", "marker", "order" ) %in% names(sobj@misc$celltypes))){
		message("[INFO] Missing required columns in sobj@misc$celltypes")
	}
        if (!all(unique(sobj@misc$celltypes$category) %in% colnames(sobj@meta.data))){
        	warning('[ERROR]: All values of unique(sobj@misc$celltypes$category) are not colnames in sobj@meta.data')
        } 
        

        #----------------
        # sobj@misc$experiment
        #----------------
        # if description column exists in the input, put it in so it shows up in "Notes / Caveats" table on singlecellportal
        # Assign metadata
	# In addition, following information will be shown in the dataset information page:
	# info: Will be shown in the column, Cells / Donors.
	# notes: Will be shown in the column, Notes / Caveats.
	# reference: Will be shown in the column, Reference / Publication.
	# link: Will be used as link icon in the column, Reference / Publication.

        sobj@misc$experiment$experiment <- sub("\\.rds$", "", rds_out)  ## THIS IS THE UNIQUE ID 
        sobj@misc$experiment$study <- sub("\\.rds$", "", gsub("_", " ", rds_out))  ## Name of the study (will be shown in the "dataset" column in the table)
        sobj@misc$experiment$order[1] <- 0
        sobj@misc$experiment$class <- 'oncology'
        sobj@misc$experiment$type <- 'singlecell'
        sobj@misc$experiment$species <- 'HS'
        PUBMEDID <- strsplit(rds_out, '_')[[1]][3] #pubmedid
        sobj@misc$experiment$reference <- PUBMEDID
	sobj@misc$experiment$notes <- DESCRIPTION
        

 	## isValid on line 909 https://github.com/Gilead-Research-Data-Sciences/scRDS/blob/f16e543657d9c214fdb5d84ba2e7ba606e27d39a/R/ingest.R        
        if (isValid(sobj, unique(sobj@misc$celltypes$category))==FALSE){
                ### Incase the error is: 
                ###   Data normalization might have happened after filtering. GetAssay(object)@data is not reproducible from GetAssay(object)@count and object$nCount_RNA.
	        ###   Failed to find a way to reproduce GetAssay(object)@data from GetAssay(object)@count and object$nCount_RNA.
                
        	sobj[['RNA']]@counts <- sobj[['RNA']]@data
					sobj[['RNA']]@counts@x <- (exp(sobj[['RNA']]@data@x) - 1) / 10000
					sobj@meta.data$nCount_RNA <- 1

                # Check if above fixed this error
  	        if (isValid(sobj, unique(sobj@misc$celltypes$category))==FALSE){
    	    	        stop('[ERROR] HALTING: Something is wrong. Rerun isValid manually for error message')
        	}
        }
        
        
        split_result <- strsplit(rds_in, "_")[[1]]
        if (length(split_result) < 2) stop("[ERROR]: Unable to infer subset_name from rds_in.")
        subset_name <- split_result[2]

        
        # Save the updated object prior to ingest -- but this is the object that is uploaded to ingest so any 
        # scRDS specific modification needs to be updated
        message("[INFO]: Writing the updated Seurat object: ", rds_out)
        saveRDS(sobj, file = rds_out) # do this before editing the counts and data below
      

        jobid <- tryCatch({
            ## details: https://github.com/Gilead-Research-Data-Sciences/scRDS/blob/f16e543657d9c214fdb5d84ba2e7ba606e27d39a/R/ingest.R
            unique_categories_as_string=paste(unique(sobj@misc$celltypes$category), collapse=",") 
            ingest(rds_out, subset_name, unique_categories_as_string) #, uri="TEST_DB_URI") #uri="MongoDB_URI") #uri="TEST_DB_URI") #uri=MONGO_DB_URI
        }, error = function(e) {
            stop("[ERROR]: Ingestion failed for ", rds_out, " with message: ", e$message)
        })
        message("[INFO]: Ingest successful. Job ID: ", jobid)
        message("[INFO]: use checkStatus(jid), printLog(jid) to track progress.")
        
        return(jobid)
    }, error = function(e) {
        message("[ERROR]: ", e$message)
        return(NULL)
    })
}

# helper function for ingestAbioData
correct_colnames_in_misc_celltypes <- function(sobj, oldname, newname) {
    if (oldname %in% names(sobj@misc$celltypes)) {
            sobj@misc$celltypes[[newname]] <- sobj@misc$celltypes[[oldname]]
            sobj@misc$celltypes[[oldname]] <- NULL
    } 
    return(sobj)
}

jobidToLog <- function(jid) {
    log_output <- capture.output(printLog(jobId = jid)) # capture stdout
    
    if (length(log_output) == 0) {
            stop("[ERROR]: Log output is empty. Unable to analyze job status.")
    }
    
    return(log_output)
}

jobidToExperimentid <- function(jobid) {
    if (missing(jobid) || is.null(jobid) || jobid == "") {
            stop("[ERROR]: Job ID is missing or invalid.")
    }
    
    log_output <- jobidToLog(jobid)
    
    if (is.null(log_output) || length(log_output) == 0) {
            stop("[ERROR]: Log output is empty or NULL. Cannot extract experiment_id.")
    }
    
    experiment_id_line <- grep("experiment_id:", log_output, value = TRUE)
    
    if (length(experiment_id_line) == 0) {
            stop("[ERROR]: 'experiment_id' not found in the log output.")
    }
    
    experiment_id <- sub(".*experiment_id:\\s*([^ ]+).*", "\\1", experiment_id_line)
    
    if (nchar(experiment_id) == 0) {
            stop("[ERROR]: Failed to extract experiment_id from the log line.")
    }
    
    return(experiment_id)
}

searchExperimentids <- function(query) {
    library(stringr) # str_detect for pattern matching
    
    experiments <- getTestExperiments() %>%
    filter(if_any(everything(), ~ str_detect(as.character(.), regex(query, ignore_case = TRUE))))
    
    if (nrow(experiments) == 0) stop("No matching experiments found")
    
    list(
        experiment_ids = experiments$experiment_id,
        details = experiments
    )
}

experimentidToInfo <- function(eid) {
    if (missing(eid) || is.null(eid) || eid == "") {
            stop("[ERROR]: Experiment ID is missing or invalid.")
    }
    
    experiments <- getTestExperiments()
    
    x <- experiments %>% filter(experiment_id == eid)
    
    if (nrow(x) == 0) {
            stop("[ERROR]: No experiment found with the given experiment_id.")
    }
    
    dt_x <- data.table(x)
    
    colnames(dt_x) <- names(x)
    
    t(dt_x)
}

suceededJobsCleanupAll <- function(createdAt_prefix = NULL) {
    # Get the list of experiment IDs for SUCCEEDED jobs
    experiment_ids <- suceededJobsGetExperimentIds(createdAt_prefix)
    
    # Execute cleanup for each experiment ID
    lapply(experiment_ids, function(expid) {
        message(sprintf("Executing cleanup for experimentId: %s", expid))
        cleanup(experiment_id = expid)
    })
}



suceededJobsGetExperimentIds <- function(createdAt_prefix = NULL) {
    # Get the list of jobs
    succeeded_jobs <- listJobs() %>%
    filter(
        status == "SUCCEEDED",
        if (!is.null(createdAt_prefix)) startsWith(as.character(createdAt), createdAt_prefix) else TRUE
    )
    
    # Retrieve experiment IDs for each jobId
    experiment_ids <- lapply(succeeded_jobs$jobId, function(jobId) {
        message(sprintf("Fetching experiment ID for jobId: %s", jobId))
        jobidToExperimentid(jobId)
    })
    
    # Return the list of experiment IDs
    return(unlist(experiment_ids))
}


