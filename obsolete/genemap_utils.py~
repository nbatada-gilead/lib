# genemap_utils.py
# Your Name
# Date
# Description

import re
import pandas as pd
import os
from pathlib import Path
import shutil
from datetime import datetime

database = {}
DATABASE_FILE_PATH = os.path.join(os.path.dirname(__file__), 'genemap_utils_database.txt')

#------------ This will be executed when module is loaded 

def __load_database(file_path=DATABASE_FILE_PATH):
    """Parse the database file and create a nested dictionary."""
    
    global database
    database = {}

    with open(file_path, 'r') as file:
        for line in file:
            line = line.strip()
            if not line:
                continue

            key, value = line.split('=', 1)
            try:
                data_handle, sub_key = key.split('.', 1)
            except ValueError:
                print(f"Skipping invalid line: {line}")
                continue
            
            if data_handle not in database:
                database[data_handle] = {}
            database[data_handle][sub_key] = value

__load_database(DATABASE_FILE_PATH)

def __update_database(file_path=DATABASE_FILE_PATH):
    """Write the database dictionary back to the file in the original format."""
    
    if os.path.isfile(file_path):
        try:
            with open(file_path, 'r+'):
                pass
        except IOError:
            input(f"The file {file_path} is currently open. Please close it and press Enter to continue.")
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_file_path = f"{file_path}.{timestamp}.bak"
    shutil.copy(file_path, backup_file_path)

    with open(file_path, 'w') as file:
        for data_handle, sub_dict in database.items():
            if not isinstance(sub_dict, dict):
                raise ValueError(f"Expected dictionary for {data_handle}, got {type(sub_dict).__name__}.")
            
            for sub_key, value in sub_dict.items():
                if isinstance(value, str) and sub_key.startswith('files.'):
                    value = os.path.basename(value)
                
                line = f"{data_handle}.{sub_key}={value}\n"
                file.write(line)

# Data Order as in data_utils.py (you can adjust if needed)
DATA_ORDER = {
    'files.raw': 1,
    'files.map': 2,
    'source': 3,
    'species': 4,
    'script': 5
}

def listAvailableData():
    """Prints out the keys in the database dictionary."""
    print(list(database.keys()))

def queryData(query, keyword=None):
    """Search for data_handles in the database that meet certain criteria."""
    query = query.lower()
    result = []

    for data_handle in database:
        if query in data_handle.lower():
            result.append(data_handle)
        else:
            data = database[data_handle]
            if keyword and keyword in data:
                if query in str(data[keyword]).lower():
                    result.append(data_handle)
                    break
    if len(result) == 1:
        result = result[0]
    return result

def getFiles(data_handle):
    """Retrieve file paths for a specific data handle."""
    out = {}
    for key, value in database[data_handle].items():
        if key.startswith('files.'):
            if Path(value).suffix in {'.csv', '.tsv', '.txt'} and not value.startswith('http'):
                value = os.path.join(DATA_DIR, data_handle, value)

            key = key.removeprefix('files.')
            out[key] = value
        
    return out

def addNewData(data_handle, files_raw, files_map, source, species, script):
    """Add new information to the database and save it back to file."""
    global database
    
    if data_handle not in database:
        database[data_handle] = {}
    
    database[data_handle]['files.raw'] = files_raw
    database[data_handle]['files.map'] = files_map
    database[data_handle]['source'] = source
    database[data_handle]['species'] = species
    database[data_handle]['script'] = script

    __update_database()

def getInfo(data_handle, tsv_format=True):
    """Retrieve and format data from the database."""
    info = []

    def flatten_dict(d, parent_key=''):
        for k, v in d.items():
            new_key = f"{parent_key}.{k}" if parent_key else k
            if isinstance(v, dict):
                flatten_dict(v, new_key)
            else:
                info.append((new_key, v))

    data = database.get(data_handle, {})
    flatten_dict(data)
    sorted_info = sorted(info, key=lambda x: DATA_ORDER.get(x[0], float('inf')))

    if tsv_format:
        df = pd.DataFrame(sorted_info, columns=['Key', 'Value'])
        df_transposed = df.set_index('Key').T
        df_transposed.index = [data_handle]
        df_transposed.columns.name = 'data_handle'
        return df_transposed
    else:
        for key, value in sorted_info:
            print(f"{key}\t{value}")

def newDataTemplate(data_handle):
    """Print a template for the specified data handle using DATA_ORDER."""
    def print_nested_dict(prefix, d):
        for k, v in d.items():
            if isinstance(v, dict):
                print_nested_dict(f"{prefix}.{k}", v)
            else:
                print(f"{prefix}.{k}=")
    
    for key in sorted(DATA_ORDER, key=DATA_ORDER.get):
        parts = key.split('.')
        if len(parts) > 1:
            print_nested_dict(data_handle, {parts[0]: {k: '' for k in parts[1:]}})
        else:
            print(f"{data_handle}.{key}=")

def help():
    import inspect
    
    module = inspect.getmodule(inspect.currentframe())
    functions = [name for name, obj in inspect.getmembers(module, inspect.isfunction)]
    
    print("Exported Functions:")
    i = 1
    for func_name in functions:
        if func_name.startswith('help') or func_name.startswith('__'):
            continue
        func = getattr(module, func_name)
        signature = inspect.signature(func)
        docstring = inspect.getdoc(func)
        
        args = [f"{param.name}={param.default}" if param.default != inspect.Parameter.empty else param.name for param in signature.parameters.values()]
        args_str = ", ".join(args)
        print(f"{i})  - {func_name}({args_str})")
        i += 1
        if docstring:
            print(f"          {docstring}")
            print("\n")

if __name__ == "__main__":
    help()
